/******************************************************************************* * Copyright (c) 2010 Michael Doberenz. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *    Michael Doberenz - initial implementation *******************************************************************************/package org.fuwjin.lifeguard;import static java.lang.System.nanoTime;import static java.lang.Thread.interrupted;import static java.lang.Thread.yield;import static java.util.concurrent.TimeUnit.NANOSECONDS;import static org.fuwjin.lifeguard.PooledResource.newClosedResource;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import java.util.concurrent.atomic.AtomicBoolean;import org.fuwjin.util.AtomicIterable;import org.fuwjin.util.AtomicIterator;/** * A container-free pool manager. * @param <T> the pooled object type */public class LifeGuard<T>{   private static final String CLOSED_MESSAGE = "Object pool has been closed."; //$NON-NLS-1$   private final AtomicBoolean closed = new AtomicBoolean();   private final PooledResourceFactory<T> factory;   private final AtomicIterable<PooledResource<T>> pool;   private final PooledResource<T> NULL = newClosedResource();   /**    * Creates a new instance.    * @param factory the data source for the pool    * @param poolSize the maximum number of pooled objects    */   public LifeGuard(final PooledResourceFactory<T> factory, final int poolSize){      assert factory != null;      assert poolSize > 0;      this.factory = factory;      pool = new AtomicIterable<PooledResource<T>>(poolSize);      final PooledResource<T> nullObj = NULL;      final AtomicIterator<PooledResource<T>> refIter = pool.iterator();      while(refIter.hasNext()){         refIter.next();         refIter.replace(nullObj);      }   }   /**    * Closes all pool as they become available. This method will always attempt    * to close at least once, so a timeout less than or equal to zero will    * result in at most a single pass through the pool.    * @param timeout the time in seconds to wait for all pool to close    * @param unit the time unit for the timeout    * @throws InterruptedException if the thread is interrupted while waiting to    *         close active pool    * @throws TimeoutException if there are still active pool after {@code    *         timeout} seconds.    */   public void close(final long timeout, final TimeUnit unit) throws InterruptedException, TimeoutException{      if(!closed.compareAndSet(false, true)){         return;      }      boolean anyActive;      final long start = nanoTime();      do{         anyActive = false;         for(final PooledResource<T> resource: pool){            resource.closeIfReady();            anyActive = anyActive || !resource.isClosed();         }      }while(anyActive && isAlive(start, timeout, unit));      if(anyActive){         throw new TimeoutException();      }   }   /**    * Closes all pool immediately. This method may interrupt pool    * mid-transaction and should only be used as a last resort.    */   public void closeNow(){      closed.set(true);      for(final PooledResource<T> resource: pool){         resource.closeIfNotClosed();      }   }   /**    * Attempts to establish a connection with the underlying data source. Unless    * the close() method has been called, this method will always attempt to    * return a connection at least once, so a timeout less than or equal to zero    * will result in at most a single pass through the pool.    * @param timeout the time in seconds to wait for a connection to become    *        available    * @param unit the timeunit for the timeout    * @return a connection to the data source    * @throws Exception if a database access error occurs    * @throws InterruptedException if the thread is interrupted while waiting    *         for an available connection    * @throws TimeoutException if an available object cannot be found before the    *         timeout elapses    * @throws IllegalStateException if the pool has already been closed    */   public T get(final long timeout, final TimeUnit unit) throws Exception, InterruptedException, TimeoutException{      if(closed.get()){         throw new IllegalStateException(CLOSED_MESSAGE);      }      final long start = nanoTime();      do{         AtomicIterator<PooledResource<T>> iter = pool.iterator();         while(iter.hasNext()){            final PooledResource<T> resource = iter.next();            if(resource.isClosed()){               final PooledResource<T> newResource = factory.newResource();               if(iter.replace(newResource)){                  T obj = newResource.getIfReady();                  if(obj != null){                     return obj;                  }               }else{                  newResource.closeIfReady();               }            }         }         for(PooledResource<T> resource: pool){            T obj = resource.getIfReady();            if(obj != null){               return obj;            }         }      }while(isAlive(start, timeout, unit));      throw new TimeoutException();   }   /**    * Tests that {@code timeout} seconds have not elapsed since the timestamp    * {@code start}. The timestamp is given in nanoseconds.    * @param start the time in nanoseconds the timed task began    * @param timeout the duration in seconds the timed task is allocated    * @param unit the time unit for the timeout    * @return true if timeout seconds have not elapsed, false otherwise    * @throws InterruptedException if the thread has been interrupted    */   private boolean isAlive(final long start, final long timeout, final TimeUnit unit) throws InterruptedException{      yield();      if(interrupted()){         throw new InterruptedException();      }      return unit.convert(nanoTime() - start, NANOSECONDS) < timeout;   }}