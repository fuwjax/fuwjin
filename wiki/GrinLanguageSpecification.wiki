#summary Grin Language Specification

=Grin Language Specification=

The Grin Language is a fairly radical departure from traditional scripting languages. At first glance, it may seem easy to list all the things that are missing from Grin. But the driving force behind Grin is the sneaking suspicion that programming doesn't have to always be so hard. What happens if the simple stays easy, and the hard is pushed back to a supporting language?

 Catalog = _Declaration_+

Grin is written in files called Catalogs or .cat files. Catalogs are primarily collections of Script Declarations, a Script being the primary code block in Grin, much as methods are to Java. These catalogs are implicit namespaces and may be included in other catalogs through Load Declarations. An important feature to Grin is the concept of an Alias, a binding from Grin to the underlying implementation language. Aliases are declared just like Loads and Scripts in the catalog.

==Grin Declarations==

 Declaration = _!AliasDeclaration_ | _!LoadDeclaration_ | _!ScriptDeclaration_

There are 3 declarations. Alias Declarations bind a function signature to the underlying implementation language. Load Declarations import other catalogs by assigning them a local namespace. Script Declarations are the primary code blocks in catalogs.

===Alias Declaration===

 !AliasDeclaration = _!NameAlias_ | _!SignatureAlias_

Alias Declarations come in two flavors. The Name Alias allows a qualified name to be replaced with a simpler identifier. The Signature Alias maps a specific function signature to a simple name. Aliases are currently used in Invocation, ObjectType and Field resolution.

====Name Alias====

 !NameAlias = *alias* _!QualifiedName_ *as* _Name_

 !QualifiedName = _!AnnotatedName_ (*.* _!AnnotatedName_)`*`

 !AnnotatedName = _Name_ _Annotation_?
 
 Name = `[0-9A-Za-z_$]+`

 Annotation = *`[`* _Name_? *`]`*

The simple version of an alias binds a qualified name to a simple name. A qualified name or "dotted name" is a series of names, possibly just one, separated by periods (.). The alias name may then be substituted for the aliased qualified name in the rest of the catalog. 

====Signature Alias====

 !SignatureAlias = *alias* _Signature_ *as* _Name_

 Signature = _!QualifiedName_ *(* _Parameters_? *)*

 Parameters = _!QualifiedName_ (*,* _!QualifiedName_)*

This more complicated version of alias binds a function signature to a simple name. A Signature is a qualified name followed by a comma delimited list of qualified names enclosed in parentheses.

===Load Declaration===

 !LoadDeclaration = *load* _Path_ *as* _Name_

A Load Declaration imports the catalog indicated by the file system path Path as the local namespace Name. All Scripts from the loaded catalog may be referenced by their namespaced name. See the Script statement for more detail.

===Script Declaration===

 !ScriptDeclaration = _!ElevatedName_ _!ScriptBlock_ 
 
 !ElevatedName = *`<`*_Name_*>*

 !ScriptBlock =  *{* _Statement_`*` _!ReturnStatement_? *}*

A Script Declaration defines a script for later use within other scripts or from the underlying language. The script is a Script Block prefixed with an elevated name. The elevated name is technically up to the IDE for presentation, for instance, it may be rendered as bold or with a green background. However, for the sake of text only presentation, it is assumed to be a normal name enclosed in angle brackets.

The Script Block is like a standard Block statement except that it may optionally end with a return statement. Return statements are only valid as the last statement in a script block.

Scripts, when executed, have a state associated with their execution. This state is composed of an input and output stream as well as an environment, a set of named objects. In addition, the execution state may be marked as "failed". A failed execution state will not be able to resolve to a value by the underlying language implementation, generally instead resulting in an exception describing the failed state. A normal state at the end of a script execution will resolve to the value of the return statement, or to some sentinel value such as null or an unset marker if no return statement is present.

==Grin Statements==

 Statement = _!StateChangeStatement_ | _!RedirectStatement_ | _!ControlFlowStatement_

Grin Statements are the primary code elements in Grin. There are only a dozen or so statements dealing with input/output, redirection and control flow. Each statement may modify the execution state of the script, and in particular, may toggle the "failed" marker.

===State Change Statements===

 !StateChangeStatement = _!AcceptStatement_ | _!PublishStatement_ | _Assignment_

====Accept Statement====

 !AcceptStatement = _!FilterAcceptStatement_ | _!ValueAcceptStatement_
 
 !FilterAcceptStatement = *accept* *not*? *in* _Filter_

 Filter = _Range_ (*,* _Range_)`*`

 Range = . *-* . | .

 !ValueAcceptStatement = *accept* *not*? _Value_

Accept statements consume matching characters from the input stream associated with the script. The Filtered version accepts a character if it falls in any of the ranges in the filter (or doesn't fall in any ranges if the "not" keyword is present). The value version consumes a sequence of characters if the input matches the resolved value. If the "not" keyword is present in the value version, it consumes the next character from the input if the input does not match the resolved value.

An accept statement will set the state "failure" marker if the input does not match the acceptance criteria. Additionally, the statement will set the state "failure" marker if the value cannot be resolved in the value version of the statement.

====Publish Statement====

 !PublishStatement = *publish* _Value_

Publish statements serialize the resolved value to the output stream. 

A publish statement will set the state "failure" marker if the value cannot be resolved. A publish statement will *not* set the state "failure" marker if the value cannot be serialized to the output stream, as the serialization will likely be buffered. It is appropriate for the script to abort execution when the output buffer can no longer be serialized to the output stream.

====Assignment====

 Assignment = _Name_ *=* _Value_

Assignments associate the resolved value with the name in the current environment. This association will not leave the current script, i.e. a Script cannot modify the name-value mapping for the caller.

An assignment will set the state "failure" marker if the value cannot be resolved. An assignment will always successfully associate a name with a resolved value.

===Redirection Statements===

 !RedirectStatements = _Script_ | _Invocation_

====Script====

 Script = _!ElevatedNamespaceName_ _!InputValue_? _!ChainedOutput_? !_OutputAssignment_?

 !ElevatedNamespaceName = *`<`* _Namespace_? _Name_ *>*

 Namespace = _Name_ *:*

 !InputValue = *<<* _Value_

 !ChainedOutput = (*>>* _Script_)`*`

 !OutputAssignment = *>>* _Name_

Script redirections are calls to other scripts. Scripts located in the same catalog as the caller should omit the namespace, while scripts in loaded catalogs should use the local namespace from the load command.

Script redirections normally inherit the input, output and environment of the caller. After the script has executed, control will be returned to the caller. Any changes to the input and/or output will remain, however, the environment will be restored to the same mappings as before the call.

The input to a script may be redirected by a caller to a resolved value. This value will be serialized to a stream as though in a publish statement, and then passed as the input stream to the script.

The output to a script may be chained or piped as the input to another script. In this case, the output stream of the first is supplied as the input stream to the second. 

Note that while a Script may be a value, and therefore both "`<`A> >> `<`B>" and "`<`B> `<<` `<`A>" are valid statements, they are not equivalent. "`<`A> >> `<`B>" pipes the output stream from `<`A> into `<`B> as `<`B>'s input stream. "`<`B> `<<` `<`A>" first resolves `<`A> to a value, serializes that value to a temporary stream, and then uses that stream as the input for `<`B>. While this may seem unnecessarily complex at first, IO redirection was designed to mimic normal basic pipe behavior in common operating system shells and will likely be rarely used in practice.

The output of a script may be assigned to a name. As a script may be a value, this means that "result = `<`A> >> output" would map `<`A>'s return value as "result" and the output stream as "output" in the caller's environment.

The script redirection will set the state "failure" marker if the call fails or if the input value cannot be resolved.

====Invocation====
