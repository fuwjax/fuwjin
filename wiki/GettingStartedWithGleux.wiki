#summary Getting Started with Gleux

=Getting started with Gleux=

"Anything is better than nothing, but less is better than more."

Gleux represents a fundamental paradigm shift in language design, part string manipulation, part shell scripting language. In a strong sense it's the language born of the same motivation as the original wiki, the simplest possible thing that might just work.

It may shock you just how many features are "missing" from Gleux. But hopefully you'll be even more shocked by how much more is possible when starting with so little.

Gleux is at it's heart a scripting language. So we'll start with a simple script.
{{{
<HelloWorld> {
  publish "Hello, world!"
}
}}}

Surprise of all surprises... this is the tried and true hello-world script in Gleux. The script is named `<HelloWorld>` which may seem awkward at first, but there's a subtle ploy at work here. Script names are "elevated identifiers;" they are intended to be visually distinguishable and distinguished among the various identifiers in Gleux. 

By now, curly braces as block delimiters are old hat, but why, you might ask, why would Gleux stoop to old hat. The answer should not be surprising. Any restrictions to presentation are better than none, but fewer are better than more. Keep in mind here that presentation is not content, even though some modern languages such as python insist on blurring the line. White space has meaning to people and meaning to computers, but those meanings are rarely the same. So since delimiters are a necessary evil, stick with the least surprising choice.

Next, let's look at the only statement in our `<HelloWorld>` script, starting with the keyword "publish". Publish simply means to pass the following value expression, in this case "Hello, world!" to the script's output stream. Every Gleux script has an input stream and an output stream, generally these default to the standard console input and output. 

There aren't many keywords in Gleux, and publish is one of only 7 keywords that can start a statement. We'll bring up the others as we go, but the impatient may detour to the GleuxLanguage for more details.

The value expression "Hello, world!" is called a literal, or more specifically a dynamic literal because it is enclosed in double quotes. The alternative is called a static literal, and would be enclosed in single quotes. For example:
{{{
<HelloWorldRedux> {
  publish 'Hello, world!'
}
}}}
In this case, both `<HelloWorld>` and `<HelloWorldRedux>` would publish the same thing to the output stream, but the literals can be used in different ways, as we will see in a bit.

Let's look at getting some input
{{{
<BasicUserInput> {
  accept next
}
}}}

This fairly useless script will consume a single character from the input stream. Now, if there is no next character, for instance if the input stream is empty, this script will fail, which depending on the underlying implementation may be an error code or an exception. But assuming there is a next character, this script will scan it from the input and finish. So here we have 2 keywords, "accept" which tells Gleux to read from the input, and "next" which represents the next character in the stream.

Technically next here is used as a filter, there are other possible filter expressions, for instance
{{{
<HexDigit> {
  accept in 0-9, a-f, A-F
}
}}}

Here we have a script which will consume any number, or a case-insensitive A, B, C, D, E, or F. The keyword "in" indicates that there will be a set of ranges making up the filter. Ranges are comma delimited lists of contiguous characters indicated by the first and last characters separated by a hyphen. If the first and last characters are the same, then the hyphen and last character may be omitted. For instance
{{{
<ProblemCharacterFilter> {
  accept in \ , \,, \\
}
}}}
Note that space, new line, comma and backslash must all be escaped when used with the "in" keyword. This may be an opportune time to point out that Gleux is very liberal with respect to whitespace; the following script is identical to `<ProblemCharacterFilter>`
{{{
<ProblemCharacterFilterFormatted> 
  {
    accept
      in
        \     ,
        \,    ,
        \\
  }
}}}
Personally, this feels harder to read, but the whole point of presentation is to present it in whatever way feels right to you. It won't affect how Gleux interprets the script.

The "accept" keyword has a few other tricks up its sleeve. One in particular is that it is one of the few keywords that can introduce both a statement and a value. Let's examine the following script in detail.
{{{
<OurFirstRealScript> {
  ch = accept not in 1,I,l,0,O,5,S
  publish "accepted a 'ch'."
}
}}}

Let's say I'm secretly offended that the romans couldn't develop a proper number system and the arabs couldn't develop a proper alphabet forcing billions of people for thousands of years to mix two different symbol sets with horribly conflicting glyphs and therefore, I refuse, on principle, to accept those characters into my script. Just as an example. Nothing personal to the romans or arabs who might be secretly offended that I'm offended. 

So I wrote `<OurFirstRealScript>` to scan in an unoffensive character from the input stream and then publish it to the output stream. The first statement is an assignment, which is just a fancy way of saying we're going to name the result of a value expression. In this case, the value expression we're naming starts with "accept", which as I just hinted can start a statement or a value. The value of an "accept" is the character read in from the input, assuming of course that it passed the filter condition. Our filter condition this time includes the "not" keyword, which reverses the filter. So, in this example, the value of the "accept" is the next character from the input as long as it is not the number one, an uppercase I, a lowercase l, a zero, an uppercase O, a five, or an uppercase S. 

An assignment "names" the result, so the consumed character in this instance will be named "ch", which is referred to as a variable, much like "x" and "y" were variables in high school algebra. That variable name can be used throughout the rest of the script to refer back to the consumed character, whatever it may have been. In fact, we used it in the "publish" statement. 

Remember that double quotes indicate a dynamic literal. One of the features of a dynamic literal is that variables can be referenced from inside it with single quotes. So, if our input stream was "Unbelievable!", then our "accept" would consume the first character, the U. The variable "ch" would be assigned the value U and the "publish" statement would write "accepted a U" to the output stream. Note that the single quotes and the variable name are replaced with the variable value in the resulting output.

If we wanted to do the same thing with a static literal, we could have written the following script
{{{
<OurFirstReallyClunkyScript> {
  ch = accept not in 1,I,l,0,O,5,S
  publish 'accepted a '
  publish ch
  publish '.'
}
}}}
You might be thinking to yourself, why wouldn't Gluex just print out all the values that follow "publish"? And that's a good question. Keep in mind that the following script is completely identical to `<OurFirstReallyClunkyScript>`
{{{
<OurFirstReallyUnreadableClunkyScript> {
  ch = accept not in 1,I,l,0,O,5,S
  publish 'accepted a ' publish ch publish '.'
}
}}}
Remember that whitespace is for the most part a presentation detail. You're free to use whitespace to communicate your ideas in your way without being burdened by the computer's needs. The only expression is when it would be hard to determine the keywords. For instance you couldn't use "publishch" and expect Gleux to know when you wanted it to infer a statement and when you wanted an explicit variable name. Instead Gluex assumes you always mean a variable name if there's no space.

So, fine, we've seen input, output, and assignment, but we all know the dirty details of programming live in the control structures. Have you ever thought about control structures? Why did anyone ever think that "while" or "until" or "for" imply repetition? Gleux is certainly not the first to suggest the use of "repeat" as a keyword, but see if you can tell the difference with Gleux's interpretation

{{{
<RepetitionIsFun> {
  repeat accept "su"
}
}}}
We have seen this use of accept indirectly, "accept" followed by a value expression requires that the value match the input before consuming it. So "accept next" meant consume the next character from the input as long as it matches the next character from the input. 

This script will consume the "su" from "sue", the "susu" of "susurrous" and the "sususu" of "sususudio". It will fail if there is no "su" to consume, for instance if the input were "bob". If we wanted to match zero or more instead of one or more, we can use the keyword "could"
{{{
<OptionalRepetitionIsFunToo> {
  could repeat accept "su"
}
}}}
The "could" keyword can be used without "repeat" to indicate any optional statement
{{{
<OptionalStatementsAreJustAsFun> {
  could accept a,b
}
}}}
This script will consume the next character from the input if it is an a or b, but it won't fail if it doesn't match. In a certain sense "could" is a bit like an "if" statement in other languages, it allows for a branch of sorts. The corresponding statement in Gleux to "if-else" would be "either-or". 
{{{
<DecisionsDecisions> {
  either accept 'the cake is a lie'
  or abort "GlaDOS loves you"
}
}}}
So, here either the input stream starts with "the cake is a lie" or we'll abort the script with the message "GlaDOS loves you". The "abort" keyword immediately terminates the script execution with the error message corresponding to the value expression following the "abort". Either-or statements are processed in order, and you may have as many or clauses as necessary as long as there is at least one. For instance
{{{
<KindaLikeSwitchCase> {
  either num = <Int>
  or num = <Short>
  or num = <Char>
  or num = <Long>
  or num = <Byte>
  return num
}
}}}
I threw in two new ideas to see if you're still paying attention. The first (technically the last) is the "return" keyword. A script can end with a "return" statement which will pass a value expression back to the caller of the script. The second is that scripts can be called from other scripts. They may be called either as statements or value expressions, and as a value, a script will supply its return value.

So, let's say we call `<KindaLikeSwitchCase>` with the input "!23" where the `<Int>` script was defined as
{{{
<Int> {
  repeat accept 0-9
  return java.lang.Integer.valueOf(match)
}
}}}
Then `<KindaLikeSwitchCase>` will return the int 123. Once again two new features showed up. The easy one is the "match" keyword. It's like "next" in that it's a built in keyword, but where "next" returns the next character, "match" returns the characters consumed from the input by the current script. The more complicated feature is this method call-like value expression "java.lang.Integer.valueOf(match)"

Within Gleux this is called an invocation, and invocations are a special sort 