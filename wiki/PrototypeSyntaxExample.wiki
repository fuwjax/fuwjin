{{{
#I'm not 100% sure this is even possible, but it's a very interesting progression.
#Instead of treating Pogo as a grammar with some scripting tacked on, why not make it
#a proper language. There are no operators besides assignment, and very few keywords.
#
#Here's a quick summary of the keywords:
#  import    - syntactic sugar to avoid all those nasty fully qualified names
#  new       - syntactic sugar that maps to the postage "new" funciton, 
#              e.g. "new Grammar(postage)" maps to "Grammar.new(postage)"
#  do        - a loop that must execute at least once, the same as the Pogo "+" operator
#  return    - returns a value as the result of the rule. Must be the last line of the rule def.
#  match     - represents the input content currently matched by the containing rule
#  either/or - sets up a block much like Java's if/else, the same as the Pogo "/" operator
#  assert    - tests that an expression would parse without actually parsing, the same as "&"
#  not       - tests that an expression would not parse without actually parsing, the same as "!"
#              strictly speaking the keyword is really "assert not", anything else is just sugar
#  while     - a loop that may not execute, the same as "*"
#  try       - a block that optionally may exist, the same as "?"
#  in        - consumes one of the following comma-delimited ranges or characters, the same as "[]"
#              e.g. "in a-z, A-Z, 0-9, _" is the same as "[a-zA-Z0-9_]". Space and comma are escaped: "\ " or "\,"
#  @         - consumes the next character, the same as ".". I couldn't come up with a good keyword for this one.
#
#Since everything is prefix or block, the language doesn't need any end of statement terminators,
#and whitespace (including newlines) is optional. Which is why you'll sometimes see:
#  'x'
#  <Spacing>
#and other times see just:
#  'x' <Spacing>
#
#There are some interesting phrases that are possible:
#  while in a-z, A-Z
#which is [a-zA-Z]* in Pogo
#
#  do in a-z try in 0-9
#which is [a-z]+[0-9]? in Pogo
#
#  while not 'a'
#this is (!'a' .)* in Pogo, which could be mapped to
#  while{
#    assert not 'a'
#    @
#  }
#but this is more verbose and uses @. There really should be a better keyword than "@" for the Pogo "." operator.
#
#So when actually parsing, <XXX> "calls" rule XXX, 'literal' matches the literal, 
#and a method call-ish looking thing invokes the corresponding postage function.
#
#The Grammar below does not match this syntax, but the new attribute syntax on Pogo.


<Pogo>{
  <S>
  pogo = Pogo.new()
  repeat {
    name = <Name>
    accept "<-" <S>
    Pogo.add(pogo, name, <Expression>)
  }
  <EndOfFile>
  return pogo
}
<Expression>{
  first = <Sequence>
  either{
    accept "/" <S>
    option = OptionExpression.new(first)
    OptionExpression.add(option, <Sequence>)
    could repeat {
      accept "/" <S>
      OptionExpression.add(option, <Sequence>)
    }
  } or option = first
  return option
}
<Sequence>{
  first = <Prefix>
  either{
    second = <Prefix>
    seq = SequenceExpression.new(first, second)
    could repeat SequenceExpression.add(seq, <Sequence>)
  } or seq = first
  return seq
}
<Prefix>{
  either {
    accept '&' <S>
    prefix = PositiveLookaheadExpression.new(<Suffix>)
  }or{
    accept '!' <S>
    prefix = NegativeLookaheadExpression.new(<Suffix>)
  }or{
    prefix = <Suffix>
  }
  return prefix
}
<Suffix>{
  primary = <Primary>
  either {
    accept '?' <S>
    suffix = OptionalExpression.new(primary)
  } or {
    accept '*' <S>
    suffix = OptionallyRepeatingExpression.new(primary)
  } or {
    accept '+' <S>
    suffix = RequiredRepeatingExpression.new(primary)
  } or suffix = primary
  return suffix
}
<Primary>{
  either {
    name = <Name>
    is not '<'
    either {
      accept ':' <S>
      primary = Reference.new(name, <Attribute>)
    } or primary = Reference.new(name)
  } or {
    accept '(' <S>
    primary = <Expression>
    accept ')' <S>
  } or primary = <Literal>
  or primary = <Class>
  or {
    accept '.' <S>
    primary = CharClass.ANY()
  }
  return primary
}
<Name> {
  id = <Identifier> <S>
  return id
}
<Identifier>{
  <IdentStart>
  could repeat <IdentCont>
  return match
}
<IdentStart>{
  accept in a-z, A-Z, _
}
<IdentCont>{
  accept in a-z, A-Z, _, 0-9
}

<Literal> {
  either {
    accept "'"
    lit = Literal.new()
    could repeat {
      is not "'"
      Literal.append(lit, <Char>)
    }
    accept "'" <S>
  } or {
    accept '"'
    could repeat {
      is not '"'
      Literal.append(lit, <Char>)
    }
    accept '"' <S>
  }
  return lit
}
<Class> {
  accept "["
  class = CharClass.new()
  could repeat {
    is not "["
    <Range>
  }
  accept "]" <S>
}
<Range> {
  first = <Char>
  either {
    accept "-" <S>
    CharClass.add(class, first, <Char>)
  } or CharClass.add(class, first)
}
<Char> {
  either char = accept not '\\' or char = <Escape>
  return char
}
<Escape> {
  accept '\\'
  either {
    accept 'n'
    char = codepoint('\n')
  } or {
    accept 'r'
    char = codepoint('\r')
  } or {
    accept 't'
    char = codepoint('\t')
  } or {
    char = accept in ',",[,],\\
  } or {
    char = Integer.parseInt(<Octal>, 8)
  }
  return char
}
<Octal> {
  either {
    accept in 0-2
    accept in 0-7
    accept in 0-7
  } or {
    accept in 0-7
    could accept in 0-7
  }
  return match
}
<S> {
  could repeat either <Space> or <Comment>
}
<Space>{
  accept \ ,\t,\n,\r
}
<Comment>{
  accept '#'
  accept not <EndOfLine> <EndOfLine>
}
<EndOfline>{
  could accept '\r'
  accept '\n'
}
<EndOfFile>{
  is not next
}
}}}