#summary Specification for Parsing Expression Grammars

= Parsing Expression Grammar =

The PEG syntax bears some similarities to EBNF or regular expressions. However, there are two very important differences between PEGs and other grammars. PEGs do not back-track repeated elements, nor do they process subsequent alternatives once an alternative matches.

A PEG grammar is a set of rules. Each rule is a named parsing expression, so for instance {{{RuleName <- 'parsing expression'}}} is a rule named "RuleName" that will match the literal "parsing expression".

Rules may refer to other rules, for example {{{AnotherRule <- RuleName}}} is a rule named "AnotherRule" that will match whatever the rule "RuleName" matches.

By convention, the first rule in the grammar is the default start rule, though Pogo allows a parse to start from any rule.

Below is the syntax for the set of Parsing Expressions.

= Literal =

A Literal is a sequence of required characters. The characters in the Literal must appear in order consecutively in the stream. A Literal is enclosed in single or double quotes, so the rule

 {{{Literal <- 'this is a literal'}}} 

would match the input

 {{{this is a literal}}}

There is no distinction between single and double quotes, but they can't be mixed in the same literal. This means that single quoted strings can contain double quotes and vice versa.

 {{{SingleQuotesInLiteral <- "I said, 'they will not mix'" }}}

If it is necessary to include double quotes in a double quoted string, use a backslash to escape the character. This also works for line feeds, new lines, and horizontal tabs.

 {{{EscapedCharactersInLiteral <- "a backslash (\\) escapes quotes (\"), new lines (\n), line feeds (\r), or tabs (\t)." }}}

In addition, there are escapes for unprintable or unicode characters.

 {{{IntegerEscapesInLiteral <- "you can backslash an octal such as \14 or a hex \x1234." }}}

= Character Class =

A Character Class is a set of optional characters. One of the characters in the Character Class must appear next in the stream. A Character Class is enclosed in square brackets:

 {{{PassingGrade <- [ABC] }}}

So the previous rule would match any single A, B, or C. A Character Class may contain a range of characters.

 {{{AnyLetter <- [a-zA-Z] }}}

If a Character Class needs to contain a square bracket or a hyphen, escape them with a backslash. The next rule would match a single open or close square bracket or hyphen.

 {{{EscpaedCharacterClass <- [\[\-\]] }}}

= Character Wildcard =

A Character Wildcard consumes the next character from the stream. The Character Wildcard is a single period.

 {{{AnySingleChar <- . }}}

= Sequence =

A Sequence is a required set of Parsing Expressions. Each expression in the Sequence must appear in order consecutively on the stream. Whitespace is not required.

 {{{XmlIgnoreCase <- [Xx] [Mm] [Ll] }}}

= Option =

An Option is a set of alternative Parsing Expressions. One of the expressions in the Option must appear next in the stream. The expressions are tested in order, as soon as one expression matches, the remaining expressions will not be attempted, even if the parse later fails.

 {{{SmallNumbers <- 'one' / 'two' / 'three' }}}

= Grouping =

Options have a higher precedence than sequences, so if you want to embed an option in a sequence, use parentheses.

 {{{EitherOrRule <- Person ('and' / 'or') Person}}}

= Optional =

An Optional expression will match zero or one times. If the expression matches the stream it will be consumed. Any expression may be made Optional by adding a question mark as a suffix.

 {{{OptionalLiteral <- 'optional'? }}}

= Optional Series =

An Optional Series expression will match zero or more times. As long as the expression matches the stream it will be consumed. Any expression may be made an Optional Series by adding an asterisk as a suffix.

 {{{OptionalLowercaseIdentifier <- [a-z]* }}}

= Required Series =

A Required Series expression will match one or more times. The expression must appear next on the stream and as long as the expression matches the stream it will be consumed. Any expression may be made a Required Series by adding a plus as a suffix.

 {{{RequiredInteger <- [0-9]+ }}}

= Positive Lookahead =

A Positive Lookahead expression asserts that it would match the stream, but without consuming anything. Any expression may be made a Positive Lookahead by adding an ampersand as a prefix.

 {{{Adjective <- ('find' / 'discuss') &'ing' }}}

= Negative Lookahead =

A Negative Lookahead expression asserts that it would not match the stream. Any expression may be made a Negative Lookahead by adding an exclamation point as a prefix.

 {{{NotNext <- !'next' }}}
