
    This file is part of JON.

    JON is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published 
    by the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    JON is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    Copyright 2007 Michael Doberenz
--------------------------------------------------------------------------------

    Release Notes - August 25, 2007

    Java Object Notation - 1.0.0
      http://jon.sf.net
      
    Description:
		Java Object Notation is an extension to the JSON data format
		suitable for the serialization of Java objects. The intuitive
		format and the simple yet extensible library allow both humans
		and computers to read and write complex object graphs.
		
		Note that serialized objects do not need to implement any interface
		or explicitly manage their own serialization or deserialization.
		For a description of the output format or the default mapping between
		objects and JON, please visit the project homepage at http://jon.sf.net.

    Usage:
      There are two main ways to write to JON, either through a writer created
      from an IndirectTypeLibrary or from an IndirectType. Here we create a writer
      from a library and write out an object obj.

CachedAppendable appender = new DefaultCachedAppender();
IndirectTypeLibrary library = new ClassTypeLibrary();
Writer writer = library.createWriter(appender);
try{
	writer.write(obj);
}catch(SerialFormatException e){
	// the appender did not allow JON formatted output 
}catch(ObjectAccessException e){
	// an object prevented the access of a member
}
      
      Or we can create a writer from an IndirectType. This writer will not write 
      out a class cast if the supplied object is of the expected class type. Note
      that the exceptions are still thrown, but are omitted here for brevity.
      
CachedAppendable appender = new DefaultCachedAppender();
IndirectTypeLibrary library = new ClassTypeLibrary();
IndirectType type = library.getType(SomeClass.class);
Writer writer = type.createWriter(appender);
writer.write(obj);

      Reading works the same way. In addition to the two ways of generating a reader,
      there are two methods for reading. Reader.read() just reads and creates the next
      object from the input, while Reader.read(obj) reads the input and attempts to store
      it in the supplied object. Here we create a reader from the library and use the 
      default read method.
      
CachedLexable lexer = new DefaultCachedLexer(jonString);
IndirectTypeLibrary library = new ClassTypeLibrary();
Reader reader = library.createReader(lexer);
try{
	obj = reader.read();
}catch(SerialFormatException e){
	// the lexer does not have JON formatted input 
}catch(ObjectAccessException e){
	// an object prevented creation, access of a member, or storage of a parsed value
}
      
      Or we can create a reader from an IndirectType and call the fill read method. Again,
      the exceptions are omitted for brevity.
      
CachedLexable lexer = new DefaultCachedLexer(jonString);
IndirectTypeLibrary library = new ClassTypeLibrary();
IndirectType type = library.getType(SomeClass.class);
Reader reader = type.createReader(lexer);
obj = reader.read(source);

      For forums, feature requests and support, please visit the sourceforge project page at
      http://sf.net/projects/jon.