#-------------------------------------------------------------------------------
# Copyright (c) 2011 Michael Doberenz.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
# 
# Contributors:
#     Michael Doberenz - initial API and implementation
#-------------------------------------------------------------------------------
alias java.lang.StringBuilder as StringBuilder
alias java.lang.Boolean as Boolean
alias java.lang.Character as Character
alias java.lang.Object as Object
alias java.util.ArrayList as ArrayList
alias java.util.concurrent.atomic.AtomicInteger as AtomicInteger
alias org.fuwjin.chessur.AbortStatement as AbortStatement
alias org.fuwjin.chessur.Assignment as Assignment
alias org.fuwjin.chessur.Block as Block
alias org.fuwjin.chessur.CouldStatement as CouldStatement
alias org.fuwjin.chessur.Declaration as Declaration
alias org.fuwjin.chessur.EitherOrStatement as EitherOrStatement
alias org.fuwjin.chessur.Filter as Filter
alias org.fuwjin.chessur.FilterAcceptStatement as FilterAcceptStatement
alias org.fuwjin.chessur.Catalog as Catalog
alias org.fuwjin.chessur.Invocation as Invocation
alias org.fuwjin.chessur.IsStatement as IsStatement
alias org.fuwjin.chessur.Literal as Literal
alias org.fuwjin.chessur.CompositeLiteral as CompositeLiteral
alias org.fuwjin.chessur.PublishStatement as PublishStatement
alias org.fuwjin.chessur.RepeatStatement as RepeatStatement
alias org.fuwjin.chessur.Script as Script
alias org.fuwjin.chessur.ValueAcceptStatement as ValueAcceptStatement
alias org.fuwjin.chessur.Variable as Variable
alias org.fuwjin.util.CodePointSet$Range as Range
alias org.fuwjin.util.StringUtils as StringUtils
alias org.fuwjin.chessur.Indent as Indent
alias org.fuwjin.chessur.NameIndex as NameIndex
alias org.fuwjin.dinah.Function as Function
alias org.fuwjin.dinah.function.ConstructorFunction as ConstructorFunction
alias org.fuwjin.dinah.function.FieldAccessFunction as FieldAccessFunction
alias org.fuwjin.dinah.function.FieldMutatorFunction as FieldMutatorFunction
alias org.fuwjin.dinah.function.InstanceOfFunction as InstanceOfFunction
alias org.fuwjin.dinah.function.MethodFunction as MethodFunction
alias org.fuwjin.dinah.function.StaticFieldAccessFunction as StaticFieldAccessFunction
alias org.fuwjin.dinah.function.StaticFieldMutatorFunction as StaticFieldMutatorFunction
alias org.fuwjin.dinah.function.StaticMethodFunction as StaticMethodFunction
alias org.fuwjin.dinah.function.VarArgsFunction as VarArgsFunction
alias org.fuwjin.util.TypeUtils.toWrapper as toWrapper
alias java.lang.Class as Class
alias java.lang.reflect.Constructor as Constructor
alias java.lang.reflect.Method as Method
alias java.lang.reflect.Field as Field
alias java.lang.Iterable.iterator as iterator
alias java.util.Iterator.next as getNext
alias java.util.Iterator.hasNext as hasNext
alias java.util.Arrays.asList as asList
alias java.util.Map$Entry.getKey as key
alias java.util.Map$Entry.getValue as value

<Catalog>{
  <Preamble>
  varIndex = AtomicInteger.new()
  indexer = NameIndex.new()
  specs = iterator(Catalog.scripts(cat))
  repeat <ScriptDeclaration>
  is not hasNext(specs)
  <Postscript>
}
<Postscript>{
  publish "
  
  public static Object interpret(final CharSequence in, final Appendable out, final Map\<String, ?\> environment) throws 'className'Exception {
    final StringCursor input = new StringCursor(in, out);"
  size = NameIndex.size(indexer)
  publish "
    final Object[] env = new Object['size'];"
  entries = iterator(NameIndex.entries(indexer))
  could repeat {
    entry = getNext(entries)
    name = key(entry)
    index = value(entry)
    publish "
    env['index'] = environment.containsKey(\"'name'\") ? environment.get(\"'name'\") : UNSET;"
  }
  is not hasNext(entries)
  rootName = Catalog.rootName(cat)
  publish "
    return 'rootName'(input, env);
  }
}
"
}
<Preamble>{
  publish "/*******************************************************************************
 * Copyright (c) 2011 Michael Doberenz.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Michael Doberenz - initial API and implementation
 ******************************************************************************/
package 'package';

import java.io.IOException;
import java.util.Map;

public class 'className'Interpreter {
  private static final Object UNSET = new Object() {
    public String toString() {
      return \"UNSET\";
    }
  };

  public static class 'className'Exception extends Exception {
    private static final long serialVersionUID = 1; 
    'className'Exception(final String message) {
      super(message);
    }
    
    'className'Exception(final String message, final Throwable cause) {
      super(message, cause);
    }
  }
  
  private static class StringCursor {
    private int pos;
    private int line;
    private int column;
    private final CharSequence seq;
    private final int start;
    private final StringCursor parent;
    private final Appendable appender;
    
    public StringCursor(final CharSequence seq, final Appendable appender) {
      this(0, 1, 1, seq, appender, null);
    }
    
    public StringCursor(final int start, final int line, final int column, final CharSequence seq, Appendable appender, final StringCursor parent) {
      this.start = start;
      pos = start;
      this.seq = seq;
      this.parent = parent;
      this.line = line;
      this.column = column;
      this.appender = appender;
    }
    
    public int accept() throws 'className'Exception {
      checkBounds(pos);
      return advance();
    }
    
    public int accept(final String expected) throws 'className'Exception {
      if(expected == null || expected.length() == 0) {
        throw ex(\"UNSET\");
      }
      checkBounds(pos + expected.length() - 1);
      final CharSequence sub = seq.subSequence(pos, pos + expected.length());
      if(!sub.equals(expected)) {
        throw ex(\"failed while matching \"+expected);
      }
      final int stop = pos + expected.length() - 1;
      while(pos < stop) {
        advance();
      }
      return advance();
    }
    
    public int acceptIn(final String name, final String set) throws 'className'Exception {
      checkBounds(pos);
      if(set.indexOf(seq.charAt(pos)) < 0) {
        throw ex(\"Did not match filter: \"+name);
      }
      return advance();
    }
    
    public int acceptNot(final String expected) throws 'className'Exception {
      if(expected == null || expected.length() == 0) {
        throw ex(\"UNSET\");
      }
      if(pos + expected.length() - 1 >= seq.length()) {
        return accept();
      }       
      if(seq.subSequence(pos, pos + expected.length()).equals(expected)) {
        throw ex(\"failed while matching \"+expected);
      }
      return advance();
    }
    
    public int acceptNotIn(final String name, final String set) throws 'className'Exception {
      checkBounds(pos);
      if(set.indexOf(seq.charAt(pos)) >= 0) {
        throw ex(\"Unexpected match: \"+name);
      }
      return advance();
    }
    
    public void publish(final Object value) throws 'className'Exception {
      try {
        appender.append(value.toString());
      } catch(IOException e) {
        throw ex(e);
      }
    }
    
    public Object isSet(final String name, final Object value) throws 'className'Exception {
      if(UNSET.equals(value)) {
        throw ex(\"variable \"+name+\" is unset\");
      }
      return value;
    }
    
    protected void checkBounds(final int p) throws 'className'Exception {
      if(p >= seq.length()) {
        throw ex(\"unexpected EOF\");
      }
    }
    
    public void commit() {
      parent.pos = pos;
      parent.line = line;
      parent.column = column;
    }
    
    public 'className'Exception ex(final String message) {
      if(pos >= seq.length()) {
        return new 'className'Exception(message+ \": [\" + line + \",\" + column + \"] EOF -> [1,0] SOF\");
      }
      return new 'className'Exception(message+ \": [\" + line + \",\" + column + \"] '\"+ seq.charAt(pos)+\"' -> [1,0] SOF\");
    }
    
    public 'className'Exception ex(final Throwable cause) {
      return new 'className'Exception(\"[\" + line + \",\" + column + \"]\", cause);
    }
    
    private int advance() {
      final char ch = seq.charAt(pos++);
       if(ch == \'\\n\') {
         line++;
         column = 1;
       } else {
         column++;
       }
       return ch;
    }
    
    public int next() throws 'className'Exception {
      checkBounds(pos);
      return seq.charAt(pos);
    }
    
    public StringCursor sub() {
      return new StringCursor(pos, line, column, seq, appender, this);
    }
    
    public String match() {
      return seq.subSequence(start, pos).toString();
    }
  }"   
}
<ScriptDeclaration>{
  spec = Script.declaration(getNext(specs))
  name = Declaration.name(spec)
  value = Declaration.returns(spec)
  indent = Indent.new()
  publish "\n'indent'private static Object 'name'(final StringCursor input, final Object... parentEnv) throws 'className'Exception {
    final Object[] env = new Object[parentEnv.length];
    System.arraycopy(parentEnv, 0, env, 0, env.length);"
  Indent.increase(indent)
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = input.sub();"
  statements = iterator(Declaration.statements(spec))
  could repeat {
    statement = getNext(statements)
    <Statement>
  }
  publish "'indent''input'.commit();"
  is not hasNext(statements)
  either{
    is value
    publish "'indent'return '<Value>';"
  }or{
    publish "'indent'return null;"
  }
  Indent.decrease(indent)
  publish "'indent'}"
}

<Value>{
  statement = value
  either result = <Script>
  or result = <StaticLiteral>
  or result = <DynamicLiteral>
  or result = <AcceptValue>
  or result = <NextValue>
  or result = <MatchValue>
  or result = <Invocation>
  or result = <Variable>
  return result
}
<Statement>{
  either <IsStatement>
  or <EitherOrStatement>
  or <CouldStatement>
  or <RepeatStatement>
  or <AcceptStatement>
  or <PublishStatement>
  or <AbortStatement>
  or <ScriptStatement>
  or <Block>
  or <Assignment>
  or <InvocationStatement>
}

<IsStatement>{
  is IsStatement.instanceof(statement)
  value = IsStatement.value(statement)
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  oldInput = input
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = 'oldInput'.sub();"
  either {
    is IsStatement.isNot(statement)
    publish "'indent'boolean b = true;"
    publish "'indent'try {"
    Indent.increase(indent)
    publish "'indent'if((Object)'<Value>' == Boolean.FALSE) {"
    publish "'indent'  b = false;"
    publish "'indent'}"
    Indent.decrease(indent)
    exIndex = AtomicInteger.incrementAndGet(varIndex)
    exception = "e'exIndex'"
    publish "'indent'} catch(final 'className'Exception 'exception') {"
    publish "'indent'  b = false;"
    publish "'indent'}"
    publish "'indent'if(b){"
    publish "'indent'  throw 'input'.ex(\"unexpected value\");"
    publish "'indent'}"
  } or {
    publish "'indent'if((Object)'<Value>' == Boolean.FALSE) {"
    publish "'indent'  throw 'input'.ex(\"check failed\");"
    publish "'indent'}"
  }
}
<EitherOrStatement>{
  is EitherOrStatement.instanceof(statement)
  stmt = statement
  statements = iterator(EitherOrStatement.statements(stmt))
  publish "'indent'try {"
  Indent.increase(indent)
  statement = getNext(statements)
  <Statement>
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  Indent.increase(indent)
  <OrStatement>
  is not hasNext(statements)
  Indent.decrease(indent)
  publish "'indent'}"
}
<OrStatement>{
  statement = getNext(statements)
  either {
    is hasNext(statements)
    publish "'indent'try {"
    Indent.increase(indent)
    <Statement>
    Indent.decrease(indent)
    exIndex = AtomicInteger.incrementAndGet(varIndex)
    exception = "e'exIndex'"
    publish "'indent'} catch(final 'className'Exception 'exception') {"
    Indent.increase(indent)
    <OrStatement>
    Indent.decrease(indent)
    publish "'indent'}"
  } or {
    <Statement>
  }  
}
<CouldStatement>{
  is CouldStatement.instanceof(statement)
  stmt = statement
  publish "'indent'try {"
  Indent.increase(indent)
  statement = CouldStatement.statement(stmt)
  <Statement>
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  publish "'indent'  //continue"
  publish "'indent'}"
}
<RepeatStatement>{
  is RepeatStatement.instanceof(statement)
  stmt = statement
  statement = RepeatStatement.statement(stmt)
  <Statement>
  publish "'indent'try {"
  Indent.increase(indent)
  publish "'indent'while(true) {"
  Indent.increase(indent)
  <Statement>
  Indent.decrease(indent)
  publish "'indent'}"
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  publish "'indent'  //continue"
  publish "'indent'}"
}
<AcceptStatement>{
  either <FilterAcceptStatement>
  or <ValueAcceptStatement>
}
<ValueAcceptStatement>{
  is ValueAcceptStatement.instanceof(statement)
  publish "'indent''input'.accept"
  could {
    is ValueAcceptStatement.isNot(statement)
    publish 'Not'
  }
  value = ValueAcceptStatement.value(statement)
  publish '('
  could {
    is not Object.equals(Variable.NEXT(), value)
    publish <Value>
  }
  publish ');'
}
<FilterAcceptStatement>{
  is FilterAcceptStatement.instanceof(statement)
  publish "'indent''input'.accept"
  could {
    is FilterAcceptStatement.isNot(statement)
    publish "Not"
  }
  filter = FilterAcceptStatement.filter(statement)
  publish "In(\"'filter'\",\"'<Filter>'\");"
}
<AcceptValue>{
  either value = <FilterAcceptValue>
  or value = <ValueAcceptValue>
  return value
}
<ValueAcceptValue>{
  is ValueAcceptStatement.instanceof(statement)
  value = ValueAcceptStatement.value(statement)
  either {
    is ValueAcceptStatement.isNot(statement)
    notted = 'Not'
    val = <Value>
  } or {
    notted = ''
    either {
      is not Object.equals(Variable.NEXT(), value)
      val = <Value>
    } or {
      val = ''
    }
  }
  return "'input'.accept'notted'('val')"
}
<FilterAcceptValue>{
  is FilterAcceptStatement.instanceof(statement)
  either {
    is FilterAcceptStatement.isNot(statement)
    notted = 'Not'
  } or {
    notted = ''
  }
  filter = FilterAcceptStatement.filter(statement)
  return "'input'.accept'notted'In(\"'filter'\",\"'<Filter>'\")"
}
<PublishStatement>{
  is PublishStatement.instanceof(statement)
  value = PublishStatement.value(statement)
  publish "'indent''input'.publish('<Value>');"
}
<AbortStatement>{
  is AbortStatement.instanceof(statement)
  value = AbortStatement.value(statement)
  publish "'indent'throw new RuntimeException('<Value>'"
  could publish ", 'exception'"
  publish ');'
}
<Block>{
  is Block.instanceof(statement)
  block = statement
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  oldInput = input
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = 'oldInput'.sub();"
  statements = iterator(Block.statements(block))
  could repeat {
    statement = getNext(statements)
    <Statement>
  }
  is not hasNext(statements)
  publish "'indent''input'.commit();"
}
<Assignment>{
  is Assignment.instanceof(statement)
  name = Assignment.name(statement)
  index = NameIndex.indexOf(indexer, name)
  value = Assignment.value(statement)
  publish "'indent'env['index'] /*'name'*/= '<Value>';"
}
<InvocationStatement>{
  is Invocation.instanceof(statement)
  function = Invocation.function(statement)
  params = iterator(Invocation.params(statement))
  publish "'indent'try {"
  Indent.increase(indent)
  publish indent
  publish <RenderFunction>
  publish ';'
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final Exception 'exception') {"
  publish "'indent'  throw 'input'.ex('exception');"
  publish "'indent'}"
}
<Invocation>{
  is Invocation.instanceof(statement)
  function = Invocation.function(statement)
  params = iterator(Invocation.params(statement))
  return <RenderFunction>
}
<RenderFunction>{
  either <Constructor> >> render
  or <FieldAccess> >> render
  or <FieldMutator> >> render
  or <InstanceOf> >> render
  or <Method> >> render
  or <StaticFieldAccess> >> render
  or <StaticFieldMutator> >> render
  or <StaticMethod> >> render
  or <VarArgs> >> render
  is not hasNext(params)
  return render
}
<Constructor>{
  is ConstructorFunction.instanceof(function)
  constructor = ConstructorFunction.member(function)
  type = Constructor.getDeclaringClass(constructor)
  publish "new '<Type>'"
  types = iterator(asList(Constructor.getParameterTypes(constructor)))
  <Params>
}
<FieldAccess>{
  is FieldAccessFunction.instanceof(function)
  field = FieldAccessFunction.member(function)
  type = Field.getDeclaringClass(field)
  value = getNext(params)
  publish "(('<Type>')'<Value>').'Field.getName(field)'"
}
<FieldMutator>{
  is FieldMutatorFunction.instanceof(function)
  field = FieldMutatorFunction.member(function)
  type = Field.getDeclaringClass(field)
  value = getNext(params)
  publish "(('<Type>')'<Value>').'Field.getName(field)'"
  type = Field.getType(field)
  value = getNext(params)
  publish " = ('<Type>')'<Value>'"
}
<InstanceOf> {
  is InstanceOfFunction.instanceof(function)
  type = InstanceOfFunction.type(function)
  value = getNext(params)
  publish "'<Value>' instanceof '<Type>'"
}
<Method> {
  is MethodFunction.instanceof(function)
  method = MethodFunction.member(function)
  type = Method.getDeclaringClass(method)
  value = getNext(params)
  publish "(('<Type>')'<Value>').'Method.getName(method)'"
  types = iterator(asList(Method.getParameterTypes(method)))
  <Params>
}
<StaticFieldAccess> {
  is StaticFieldAccessFunction.instanceof(function)
  field = StaticFieldAccessFunction.member(function)
  type = Field.getDeclaringClass(field)
  publish "'<Type>'.'Field.getName(field)'"
}
<StaticFieldMutator>{
  is StaticFieldMutatorFunction.instanceof(function)
  field = StaticFieldMutatorFunction.member(function)
  type = Field.getDeclaringClass(field)
  publish "'<Type>'.'Field.getName(field)'"
  type = Field.getType(field)
  value = getNext(params)
  publish " = ('<Type>')'<Value>'"
}
<StaticMethod> {
  is StaticMethodFunction.instanceof(function)
  method = StaticMethodFunction.member(function)
  type = Method.getDeclaringClass(method)
  publish "'<Type>'.'Method.getName(method)'"
  types = iterator(asList(Method.getParameterTypes(method)))
  <Params>
}
<VarArgs> {
  abort "VarArgs is currently unsupported: 'Function.name(function)'"
}
<Params> {
  publish '('
  could {
    type = getNext(types)
    value = getNext(params)
    publish "('<Type>')'<Value>'"
    could repeat {
      type = getNext(types)
      value = getNext(params)
      publish ", ('<Type>')'<Value>'"
    }
  }
  is not hasNext(types)
  publish ')'
}
<Type> {
  return Class.getCanonicalName(toWrapper(type))
}

<Filter>{
  is Filter.instanceof(filter)
  filterBuffer = StringBuilder.new()
  ranges = iterator(Filter.ranges(filter))
  range = getNext(ranges)
  <Range>
  could repeat{
    range = getNext(ranges)
    <Range>
  }
  is not hasNext(ranges)
  return StringBuilder.toString(filterBuffer)
}
<Range>{
  is Range.instanceof(range)
  chars = iterator(Range.chars(range))
  repeat {
    ch = getNext(chars)
    StringBuilder.append(filterBuffer, Literal.dynamicEscape(ch))
  }
  is not hasNext(chars)
}

<StaticLiteral>{
  is Literal.instanceof(value)
  chars = iterator(Literal.chars(value))
  builder = StringBuilder.new()
  could repeat{
    ch = getNext(chars)
    StringBuilder.append(builder, Literal.dynamicEscape(ch))
  }
  is not hasNext(chars)
  return "\"'builder'\""
}
<DynamicLiteral>{
  is CompositeLiteral.instanceof(value)
  composite = value
  values = iterator(CompositeLiteral.values(composite))
  could {
    value = getNext(values)
    either {
      is not hasNext(values)
      result = <Value>
    } or {
      list = ArrayList.new()
      ArrayList.add(list, <Value>)
      repeat{
        value = getNext(values)
        ArrayList.add(list, <Value>)
      }
      is not hasNext(values)
      result = StringUtils.join(" + ", list)
    }
  }
  return result
}
<NextValue>{
  is Object.equals(Variable.NEXT(), value)
  return "'input'.next()"
}
<MatchValue>{
  is Object.equals(Variable.MATCH(), value)
  return "'input'.match()"
}

<ScriptStatement>{
  is Script.instanceof(statement)
  name = Script.name(statement)
  publish "'indent''name'('input', env);"
}
<Script>{
  is Script.instanceof(statement)
  name = Script.name(statement)
  return "'name'('input', env)"
}
<Variable>{
  is Variable.instanceof(value)
  name = Variable.name(value)
  index = NameIndex.indexOf(indexer, name)
  return "'input'.isSet(\"'name'\", env['index'])"
}
