alias java.lang.Boolean as Boolean
alias java.lang.Character as Character
alias org.fuwjin.chessur.AbortStatement as AbortStatement
alias org.fuwjin.chessur.Assignment as Assignment
alias org.fuwjin.chessur.Block as Block
alias org.fuwjin.chessur.CouldStatement as CouldStatement
alias org.fuwjin.chessur.Declaration as Declaration
alias org.fuwjin.chessur.EitherOrStatement as EitherOrStatement
alias org.fuwjin.chessur.Filter as Filter
alias org.fuwjin.chessur.FilterAcceptStatement as FilterAcceptStatement
alias org.fuwjin.chessur.Grin as Grin
alias org.fuwjin.chessur.Invocation as Invocation
alias org.fuwjin.chessur.IsStatement as IsStatement
alias org.fuwjin.chessur.Literal as Literal
alias org.fuwjin.chessur.CompositeLiteral as CompositeLiteral
alias org.fuwjin.chessur.PublishStatement as PublishStatement
alias org.fuwjin.chessur.RepeatStatement as RepeatStatement
alias org.fuwjin.chessur.Script as Script
alias org.fuwjin.chessur.ValueAcceptStatement as ValueAcceptStatement
alias org.fuwjin.chessur.Variable as Variable
alias org.fuwjin.util.StringUtils as StringUtils


<Grin>{
  could {
    repeat <AliasDeclaration>
    publish "\n"
  }
  repeat <ScriptDeclaration>
  <EndOfFile>
}
<AliasDeclaration>{
  accept 'alias' <Sep>
  either name = <QualifiedName>
  or abort "alias keyword requires a qualified name"
  either accept 'as'
  or abort "alias keyword requires as keyword" 
  <Sep>
  either alias = <Name>
  or abort "alias-as keywords require a name"
  publish "alias 'name' as 'alias'\n"
}
<ScriptDeclaration>{
  <Script>
  either accept '{'
  or abort "script declarations must start with a brace"
  <S>
  publish " {"
  indent = Indent.new()
  could repeat {
    publish "\n'indent'"
    <Statement>
  }
  could{
    accept 'return' <Sep>
    publish "\n'indent'return "
    either <Value>
    or abort "return keyword requires a value"
  }
  either accept '}'
  or abort "script declarations must end with a brace" 
  <S>
  publish "\n}\n"
}

<Value>{
  either <Script>
  or <StaticLiteral>
  or <DynamicLiteral>
  or <AcceptStatement>
  or <Invocation>
  or publish <Name>
}
<Statement>{
  either <IsStatement>
  or <EitherOrStatement>
  or <CouldStatement>
  or <RepeatStatement>
  or <AcceptStatement>
  or <PublishStatement>
  or <AbortStatement>
  or <Script>
  or <Block>
  or <Assignment>
  or <Invocation>
}

<IsStatement>{
  accept 'is' <Sep>
  publish "is "
  could {
    accept 'not' <Sep>
    publish "not "
  }
  either <InFilter> 
  or <Value>
  or abort "is keyword requires value or in keyword"
}
<EitherOrStatement>{
  accept 'either' <Sep>
  publish "either "
  either <Statement>
  or abort "either keyword requires a statement"
  either repeat{
    accept 'or' <Sep>
    publish "\n'indent'or "
    either <Statement>
    or abort "or keyword requires a statement"
  } or abort "either keyword requires at least one or keyword"
}
<CouldStatement>{
  accept 'could' <Sep>
  publish "could "
  either <Statement>
  or abort "could keyword requires a statement"
}
<RepeatStatement>{
  accept 'repeat' <Sep>
  publish "repeat "
  either <Statement>
  or abort "repeat keyword requires a statement"
}
<AcceptStatement>{
  accept 'accept' <Sep>
  publish "accept "
  could {
    accept 'not' <Sep>
    publish "not "
  }
  either <InFilter> 
  or <Value>
  or abort "accept keyword requires a value or in keyword"
}
<PublishStatement>{
  accept 'publish' <Sep>
  publish "publish "
  either <Value>
  or abort "publish keyword requires a value"
}
<AbortStatement>{
  accept 'abort' <Sep>
  publish "abort "
  either <Value>
  or abort "abort keyword requires a value"
}
<Block>{
  accept '{' <S>
  publish "{"
  Indent.increase(indent)
  could repeat {
    publish "\n'indent'"
    <Statement>
  }
  either accept '}'
  or abort "block must end with a brace"
  <S>
  Indent.decrease(indent)
  publish "\n'indent'} "
}
<Assignment>{
  name = <Name>
  accept '=' <S>
  publish "'name' = "
  either <Value>
  or abort "assignment requires a value"
}
<Invocation>{
  name = <QualifiedName>
  accept '(' <S>
  publish "'name'("
  could{
    <Value>
    could repeat{
      accept ',' <S>
      publish ", "
      either <Value>
      or abort "invocation parameter must be a value"
    }
  }
  either accept ')'
  or abort "invocation must end with a parenthesis" 
  <S>
  publish ")"
}

<InFilter>{
  accept 'in' <Sep>
  publish "in "
  either <FilterRange>
  or abort "in keyword requires at least one filter"
  could repeat{
    accept ',' <S>
    publish ", "
    either <FilterRange>
    or abort "in keyword requires a filter after a comma"
  }
}
<FilterRange>{
  <FilterChar> 
  <S>
  could{
    accept '-' 
    <S>
    publish '-'
    <FilterChar>
    <S>
  }
}
<FilterChar>{
  either 
    <Escape>
  or 
    accept not '\\'
  publish match
}

<StaticLiteral>{
  accept '\''
  publish '\''
  could repeat either {
    publish accept not in \\, ' 
  } or {
    <Escape>
  }
  either accept '\''
  or abort "static literals must end with a quote" 
  <S>
  return lit
}
<DynamicLiteral>{
  accept '"'
  lit = CompositeLiteral.new()
  could repeat either {
    accept '\''
    CompositeLiteral.append(lit, Variable.new(<Identifier>))
    accept '\''
  } or {
    accept '<'
    CompositeLiteral.append(lit, Grin.get(grin, <Identifier>))
    accept '>'
  } or {
    CompositeLiteral.append(lit, <Escape>)
  } or {
    ch = accept not in \\, "
    CompositeLiteral.append(lit, ch)
  }
  either accept '"'
  or abort "dynamic literals must end with a double quote" 
  <S>
  return lit
}

<Escape>{
  accept '\\' 
  either {
    accept 'x'
    <HexDigits>
  } or {
    ch = accept next
  }
  return match
}
<HexDigits>{
  <HexDigit><HexDigit><HexDigit><HexDigit>
  return match
}
<HexDigit>{
  accept in 0-9, a-f, A-F
}

<Script>{
  accept '<'
  either id = <Identifier>
  or abort "scripts must be an identifier enclosed in angle brackets"
  either accept '>'
  or abort "scripts must end with an angle bracket" 
  <S>
  return id
}
<Name>{
  id = <Identifier> <S>
  return id
}
<QualifiedName>{
  id = <QualifiedIdentifier> <S>
  return id
}
<QualifiedIdentifier>{
  <AnnotatedIdentifier>
  could repeat{
    accept '.'
    <AnnotatedIdentifier>
  }
  return match
}
<AnnotatedIdentifier>{
  <Identifier>
  could repeat{
    accept '['
    could <Identifier>
    accept ']'
  }
}
<Identifier>{
  repeat <IdentifierChar>
  return match
}
<IdentifierChar>{
  is Character.isJavaIdentifierPart(next)
  accept next
}

<Sep>{
  is not <IdentifierChar>
  <S>
}
<S>{
  could <Space>
}
<Space>{
  repeat either accept in \ , \n, \t, \r or <Comment>
}
<Comment>{
  accept '#'
  could repeat accept not in \r, \n
  could accept '\r'
  either accept '\n'
  or <EndOfFile>
}
<EndOfFile>{
  is not next
}