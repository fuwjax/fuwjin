alias java.lang.StringBuilder as StringBuilder
alias java.lang.Boolean as Boolean
alias java.lang.Character as Character
alias java.lang.Object as Object
alias java.util.ArrayList as ArrayList
alias java.util.concurrent.atomic.AtomicInteger as AtomicInteger
alias org.fuwjin.gleux.AbortStatement as AbortStatement
alias org.fuwjin.gleux.Assignment as Assignment
alias org.fuwjin.gleux.Block as Block
alias org.fuwjin.gleux.CouldStatement as CouldStatement
alias org.fuwjin.gleux.Declaration as Declaration
alias org.fuwjin.gleux.EitherOrStatement as EitherOrStatement
alias org.fuwjin.gleux.Filter as Filter
alias org.fuwjin.gleux.FilterAcceptStatement as FilterAcceptStatement
alias org.fuwjin.gleux.Gleux as Gleux
alias org.fuwjin.gleux.Invocation as Invocation
alias org.fuwjin.gleux.IsStatement as IsStatement
alias org.fuwjin.gleux.Literal as Literal
alias org.fuwjin.gleux.CompositeLiteral as CompositeLiteral
alias org.fuwjin.gleux.PublishStatement as PublishStatement
alias org.fuwjin.gleux.RepeatStatement as RepeatStatement
alias org.fuwjin.gleux.Script as Script
alias org.fuwjin.gleux.ValueAcceptStatement as ValueAcceptStatement
alias org.fuwjin.gleux.Variable as Variable
alias org.fuwjin.util.CodePointSet$Range as Range
alias org.fuwjin.util.StringUtils as StringUtils
alias org.fuwjin.gleux.Indent as Indent
alias org.fuwjin.gleux.NameIndex as NameIndex
alias org.fuwjin.postage.FunctionRenderer as FunctionRenderer
alias java.lang.Iterable.iterator as iterator
alias java.util.Iterator.next as getNext
alias java.util.Iterator.hasNext as hasNext
alias java.util.Map$Entry.getKey as key
alias java.util.Map$Entry.getValue as value

<Gleux>{
  <Preamble>
  varIndex = AtomicInteger.new()
  indexer = NameIndex.new()
  specs = iterator(Gleux.scripts(gleux))
  repeat <ScriptDeclaration>
  is not hasNext(specs)
  <Postscript>
}
<Postscript>{
  publish "
  
  public static Object interpret(final CharSequence in, final Map\<String, ?\> environment) throws 'className'Exception {
    final StringCursor input = new StringCursor(in);"
  size = NameIndex.size(indexer)
  publish "
    final Object[] env = new Object['size'];"
  entries = iterator(NameIndex.entries(indexer))
  could repeat {
    entry = getNext(entries)
    name = key(entry)
    index = value(entry)
    publish "
    env['index'] = environment.get(\"'name'\");"
  }
  is not hasNext(entries)
  rootName = Gleux.rootName(gleux)
  publish "
    return 'rootName'(input, env);
  }
}
"
}
<Preamble>{
  publish "package 'package';

import java.util.Map;

public class 'className'Interpreter {
  public static class 'className'Exception extends Exception {
    private 'className'Exception(final String message) {
      super(message);
    }
    
    private 'className'Exception(final Throwable cause) {
      super(cause);
    }
  }
  
  private static class StringCursor {
    private int pos;
    private final CharSequence seq;
    private final int start;
    private final StringCursor parent;
    
    public StringCursor(final CharSequence seq) {
      this(0, seq, null);
    }
    
    public StringCursor(final int start, final CharSequence seq, final StringCursor parent) {
      this.start = start;
      pos = start;
      this.seq = seq;
      this.parent = parent;
    }
    
    public int accept() throws 'className'Exception {
      checkBounds(pos);
      return seq.charAt(pos++);
    }
    
    public int accept(final String expected) throws 'className'Exception {
      if(expected == null || expected.length() == 0) {
        throw new 'className'Exception(\"UNSET\");
      }
      checkBounds(pos + expected.length() - 1);
      final CharSequence sub = seq.subSequence(pos, pos + expected.length());
      if(!sub.equals(expected)) {
        throw new 'className'Exception(\"unexpected character \"+sub+\"  \"+expected);
      }
      pos = pos + expected.length();
      return seq.charAt(pos - 1);
    }
    
    public int acceptIn(final String set) throws 'className'Exception {
      checkBounds(pos);
      if(set.indexOf(seq.charAt(pos)) < 0) {
        throw new 'className'Exception(\"unexpected character\");
      }
      return seq.charAt(pos++);
    }
    
    public int acceptNot(final String expected) throws 'className'Exception {
      if(expected == null || expected.length() == 0) {
        throw new 'className'Exception(\"UNSET\");
      }
      checkBounds(pos + expected.length() - 1);
      if(seq.subSequence(pos, pos + expected.length()).equals(expected)) {
        throw new 'className'Exception(\"unexpected character\");
      }
      return seq.charAt(pos++);
    }
    
    public int acceptNotIn(final String set) throws 'className'Exception {
      checkBounds(pos);
      if(set.indexOf(seq.charAt(pos)) >= 0) {
        throw new 'className'Exception(\"unexpected character\");
      }
      return seq.charAt(pos++);
    }
    
    protected void checkBounds(final int p) throws 'className'Exception {
      if(p >= seq.length()) {
        throw new 'className'Exception(\"unexpected EOF\");
      }
    }
    
    public void commit() {
      parent.pos = pos;
    }
    
    public int next() throws 'className'Exception {
      checkBounds(pos);
      return seq.charAt(pos);
    }
    
    public StringCursor sub() {
      return new StringCursor(pos, seq, this);
    }
    
    public String match() {
      return seq.subSequence(start, pos).toString();
    }
  }"   
}
<ScriptDeclaration>{
  spec = Script.declaration(getNext(specs))
  name = Declaration.name(spec)
  value = Declaration.returns(spec)
  indent = Indent.new()
  publish "\n'indent'private static Object 'name'(final StringCursor input, final Object... parentEnv) throws 'className'Exception {
    final Object[] env = new Object[parentEnv.length];
    System.arraycopy(parentEnv, 0, env, 0, env.length);"
  Indent.increase(indent)
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = input.sub();"
  statements = iterator(Declaration.statements(spec))
  could repeat {
    statement = getNext(statements)
    <Statement>
  }
  publish "'indent''input'.commit();"
  is not hasNext(statements)
  either{
    is value
    publish "'indent'return <Value>;"
  }or{
    publish "'indent'return null;"
  }
  Indent.decrease(indent)
  publish "'indent'}"
}

<Value>{
  statement = value
  either result = <Script>
  or result = <StaticLiteral>
  or result = <DynamicLiteral>
  or result = <AcceptValue>
  or result = <NextValue>
  or result = <MatchValue>
  or result = <Invocation>
  or result = <Variable>
  return result
}
<Statement>{
  either <IsStatement>
  or <EitherOrStatement>
  or <CouldStatement>
  or <RepeatStatement>
  or <AcceptStatement>
  or <PublishStatement>
  or <AbortStatement>
  or <ScriptStatement>
  or <Block>
  or <Assignment>
  or <InvocationStatement>
}

<IsStatement>{
  is IsStatement.instanceof(statement)
  value = IsStatement.value(statement)
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  oldInput = input
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = 'oldInput'.sub();"
  either {
    is IsStatement.isNot(statement)
    publish "'indent'boolean b = true;"
    publish "'indent'try {"
    Indent.increase(indent)
    publish "'indent'if((Object)<Value> == Boolean.FALSE) {"
    publish "'indent'  b = false;"
    publish "'indent'}"
    Indent.decrease(indent)
    exIndex = AtomicInteger.incrementAndGet(varIndex)
    exception = "e'exIndex'"
    publish "'indent'} catch(final 'className'Exception 'exception') {"
    publish "'indent'  b = false;"
    publish "'indent'}"
    publish "'indent'if(b){"
    publish "'indent'  throw new 'className'Exception(\"unexpected value\");"
    publish "'indent'}"
  } or {
    publish "'indent'if((Object)<Value> == Boolean.FALSE) {"
    publish "'indent'  throw new 'className'Exception(\"check failed\");"
    publish "'indent'}"
  }
}
<EitherOrStatement>{
  is EitherOrStatement.instanceof(statement)
  stmt = statement
  statements = iterator(EitherOrStatement.statements(stmt))
  publish "'indent'try {"
  Indent.increase(indent)
  statement = getNext(statements)
  <Statement>
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  Indent.increase(indent)
  <OrStatement>
  is not hasNext(statements)
  Indent.decrease(indent)
  publish "'indent'}"
}
<OrStatement>{
  statement = getNext(statements)
  either {
    is hasNext(statements)
    publish "'indent'try {"
    Indent.increase(indent)
    <Statement>
    Indent.decrease(indent)
    exIndex = AtomicInteger.incrementAndGet(varIndex)
    exception = "e'exIndex'"
    publish "'indent'} catch(final 'className'Exception 'exception') {"
    Indent.increase(indent)
    <OrStatement>
    Indent.decrease(indent)
    publish "'indent'}"
  } or {
    <Statement>
  }  
}
<CouldStatement>{
  is CouldStatement.instanceof(statement)
  stmt = statement
  publish "'indent'try {"
  Indent.increase(indent)
  statement = CouldStatement.statement(stmt)
  <Statement>
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  publish "'indent'  //continue"
  publish "'indent'}"
}
<RepeatStatement>{
  is RepeatStatement.instanceof(statement)
  stmt = statement
  statement = RepeatStatement.statement(stmt)
  <Statement>
  publish "'indent'try {"
  Indent.increase(indent)
  publish "'indent'while(true) {"
  Indent.increase(indent)
  <Statement>
  Indent.decrease(indent)
  publish "'indent'}"
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final 'className'Exception 'exception') {"
  publish "'indent'  //continue"
  publish "'indent'}"
}
<AcceptStatement>{
  either <FilterAcceptStatement>
  or <ValueAcceptStatement>
}
<ValueAcceptStatement>{
  is ValueAcceptStatement.instanceof(statement)
  publish "'indent''input'.accept"
  could {
    is ValueAcceptStatement.isNot(statement)
    publish 'Not'
  }
  value = ValueAcceptStatement.value(statement)
  publish '('
  could {
    is not Object.equals(Variable.NEXT(), value)
    publish <Value>
  }
  publish ');'
}
<FilterAcceptStatement>{
  is FilterAcceptStatement.instanceof(statement)
  publish "'indent''input'.accept"
  could {
    is FilterAcceptStatement.isNot(statement)
    publish "Not"
  }
  filter = FilterAcceptStatement.filter(statement)
  publish "In(\"<Filter>\");"
}
<AcceptValue>{
  either value = <FilterAcceptValue>
  or value = <ValueAcceptValue>
  return value
}
<ValueAcceptValue>{
  is ValueAcceptStatement.instanceof(statement)
  value = ValueAcceptStatement.value(statement)
  either {
    is ValueAcceptStatement.isNot(statement)
    notted = 'Not'
    val = <Value>
  } or {
    notted = ''
    either {
      is not Object.equals(Variable.NEXT(), value)
      val = <Value>
    } or {
      val = ''
    }
  }
  return "'input'.accept'notted'('val')"
}
<FilterAcceptValue>{
  is FilterAcceptStatement.instanceof(statement)
  either {
    is FilterAcceptStatement.isNot(statement)
    notted = 'Not'
  } or {
    notted = ''
  }
  filter = FilterAcceptStatement.filter(statement)
  return "'input'.accept'notted'In(\"<Filter>\")"
}
<PublishStatement>{
  is PublishStatement.instanceof(statement)
  publish "publish "
  value = PublishStatement.value(statement)
  <Value>
}
<AbortStatement>{
  is AbortStatement.instanceof(statement)
  value = AbortStatement.value(statement)
  publish "'indent'throw new RuntimeException(<Value>"
  could publish ", 'exception'"
  publish ');'
}
<Block>{
  is Block.instanceof(statement)
  block = statement
  subIndex = AtomicInteger.incrementAndGet(varIndex)
  oldInput = input
  input = "sub'subIndex'"
  publish "'indent'final StringCursor 'input' = 'oldInput'.sub();"
  statements = iterator(Block.statements(block))
  could repeat {
    statement = getNext(statements)
    <Statement>
  }
  is not hasNext(statements)
  publish "'indent''input'.commit();"
}
<Assignment>{
  is Assignment.instanceof(statement)
  name = Assignment.name(statement)
  index = NameIndex.indexOf(indexer, name)
  value = Assignment.value(statement)
  publish "'indent'env['index'] /*'name'*/= <Value>;"
}
<InvocationStatement>{
  is Invocation.instanceof(statement)
  name = Invocation.name(statement)
  renderer = Invocation.renderer(statement)
  params = iterator(Invocation.params(statement))
  could repeat {
    value = getNext(params)
    FunctionRenderer.addArg(renderer, <Value>)
  }
  is not hasNext(params)
  publish "'indent'try {"
  Indent.increase(indent)
  publish indent
  publish FunctionRenderer.render(renderer)
  publish ';'
  Indent.decrease(indent)
  exIndex = AtomicInteger.incrementAndGet(varIndex)
  exception = "e'exIndex'"
  publish "'indent'} catch(final Exception 'exception') {"
  publish "'indent'  throw new 'className'Exception('exception');"
  publish "'indent'}"
}
<Invocation>{
  is Invocation.instanceof(statement)
  name = Invocation.name(statement)
  renderer = Invocation.renderer(statement)
  params = iterator(Invocation.params(statement))
  could repeat {
    value = getNext(params)
    FunctionRenderer.addArg(renderer, <Value>)
  }
  is not hasNext(params)
  return FunctionRenderer.render(renderer)
}

<Filter>{
  is Filter.instanceof(filter)
  filterBuffer = StringBuilder.new()
  ranges = iterator(Filter.ranges(filter))
  range = getNext(ranges)
  <Range>
  could repeat{
    range = getNext(ranges)
    <Range>
  }
  is not hasNext(ranges)
  return StringBuilder.toString(filterBuffer)
}
<Range>{
  is Range.instanceof(range)
  chars = iterator(Range.chars(range))
  repeat {
    ch = getNext(chars)
    StringBuilder.append(filterBuffer, Literal.dynamicEscape(ch))
  }
  is not hasNext(chars)
}

<StaticLiteral>{
  is Literal.instanceof(value)
  chars = iterator(Literal.chars(value))
  builder = StringBuilder.new()
  could repeat{
    ch = getNext(chars)
    StringBuilder.append(builder, Literal.dynamicEscape(ch))
  }
  is not hasNext(chars)
  return "\"'builder'\""
}
<DynamicLiteral>{
  is CompositeLiteral.instanceof(value)
  composite = value
  values = iterator(CompositeLiteral.values(composite))
  could {
    value = getNext(values)
    either {
      is not hasNext(values)
      result = <Value>
    } or {
      list = ArrayList.new()
      ArrayList.add(list, <Value>)
      repeat{
        value = getNext(values)
        ArrayList.add(list, <Value>)
      }
      is not hasNext(values)
      result = StringUtils.join(" + ", list)
    }
  }
  return result
}
<NextValue>{
  is Object.equals(Variable.NEXT(), value)
  return "'input'.next()"
}
<MatchValue>{
  is Object.equals(Variable.MATCH(), value)
  return "'input'.match()"
}

<ScriptStatement>{
  is Script.instanceof(statement)
  name = Script.name(statement)
  publish "'indent''name'('input', env);"
}
<Script>{
  is Script.instanceof(statement)
  name = Script.name(statement)
  return "'name'('input', env)"
}
<Variable>{
  is Variable.instanceof(value)
  name = Variable.name(value)
  index = NameIndex.indexOf(indexer, name)
  return "env['index']/*'name'*/"
}
